#ifndef _AUDIO_CAPTUREMGR_H_
#define _AUDIO_CAPTUREMGR_H_

#include "common.h"

#include "audio_channel.h"

#include <list>
#include <map>
#include <ev.h>

///////////////////////////////////////////////////////////////////////////////
// macros
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
// forward declarations
///////////////////////////////////////////////////////////////////////////////

class AUDIOCaptureInstance;
class AUDIOChannel;

///////////////////////////////////////////////////////////////////////////////
// class defition
///////////////////////////////////////////////////////////////////////////////

class AUDIOCaptureManager
{
	friend class AUDIOCaptureInstance;
	friend class AUDIOChannel;	

///////////////////////////////////////////////////////////////////////////////
// type defitions
///////////////////////////////////////////////////////////////////////////////

public:

	class Handler 
	{
	public:
		virtual ResultCode handle_samples(AUDIOChannel::Index index, const size_t buffer_length, AUDIOChannel::Sample *buffer_p) = 0;
	};

	typedef std::map<AUDIOChannel::Index, AUDIOChannel *>::iterator ChannelIterator;

///////////////////////////////////////////////////////////////////////////////
// public function declarations
///////////////////////////////////////////////////////////////////////////////

public:

	static AUDIOCaptureManager *get_instance();

	void add_handler(Handler *handler_p);
	void remove_handler(Handler *handler_p);

 	AUDIOChannel *find_channel(const AUDIOChannel::Index index);
	inline const size_t channel_count() const;

	inline ChannelIterator begin();
	inline ChannelIterator end();

///////////////////////////////////////////////////////////////////////////////
// private function declarations
///////////////////////////////////////////////////////////////////////////////

private:

	AUDIOCaptureManager();
	virtual ~AUDIOCaptureManager();

	AUDIOChannel::Index allocate_index();
	void add_channel(AUDIOChannel *channel_p);

///////////////////////////////////////////////////////////////////////////////
// private variable definitions
///////////////////////////////////////////////////////////////////////////////

private:
	static AUDIOCaptureManager *g_instance_p;

	struct ev_loop *m_loop_p;
	std::list<Handler *> m_handlers;
	std::list<AUDIOCaptureInstance *> m_instances;
	std::map<AUDIOChannel::Index, AUDIOChannel *> m_channels_map;
	size_t m_channel_count;

};

///////////////////////////////////////////////////////////////////////////////
// inline function implementations 
///////////////////////////////////////////////////////////////////////////////

const size_t AUDIOCaptureManager::channel_count() const
{
	return m_channel_count;
}

AUDIOCaptureManager::ChannelIterator AUDIOCaptureManager::begin()
{
	return m_channels_map.begin();
}

AUDIOCaptureManager::ChannelIterator AUDIOCaptureManager::end()
{
	return m_channels_map.end();
}

#endif
