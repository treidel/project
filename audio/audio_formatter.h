#ifndef _AUDIO_FORMATTER_H_
#define _AUDIO_FORMATTER_H_

#include "common.h"
#include "audio_channel.h"

#include <list>

#include <alsa/asoundlib.h>

///////////////////////////////////////////////////////////////////////////////
// macros
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// forward declarations
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// class definition
///////////////////////////////////////////////////////////////////////////////

class AUDIOFormatter
{

///////////////////////////////////////////////////////////////////////////////
// type definitions
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// public function declarations
///////////////////////////////////////////////////////////////////////////////

public:

    virtual ~AUDIOFormatter();

    virtual const snd_pcm_format_t format() = 0;
    virtual void format_samples(uint8_t *raw_buffer_p, AUDIOChannel::Index index, AUDIOChannel::Sample *sample_buffer_p, size_t num_samples) = 0;
    virtual const size_t sample_sizeof() = 0;


///////////////////////////////////////////////////////////////////////////////
// protected function declarations
///////////////////////////////////////////////////////////////////////////////

protected:

    AUDIOFormatter();


///////////////////////////////////////////////////////////////////////////////
// private function declarations
///////////////////////////////////////////////////////////////////////////////

private:


///////////////////////////////////////////////////////////////////////////////
// private variable definitions
///////////////////////////////////////////////////////////////////////////////

private:

};

///////////////////////////////////////////////////////////////////////////////
// class definition
///////////////////////////////////////////////////////////////////////////////

class AUDIOFormatterFactory
{

///////////////////////////////////////////////////////////////////////////////
// public function declarations
///////////////////////////////////////////////////////////////////////////////

public:

    static AUDIOFormatter *create_audio_formatter_p(snd_pcm_format_t format);
    static std::list<snd_pcm_format_t> fetch_audio_format_list();
};

///////////////////////////////////////////////////////////////////////////////
// class definition
///////////////////////////////////////////////////////////////////////////////


class AUDIOSigned16BitFormatter : public AUDIOFormatter
{

///////////////////////////////////////////////////////////////////////////////
// public function declarations
///////////////////////////////////////////////////////////////////////////////

public:
    AUDIOSigned16BitFormatter();
    ~AUDIOSigned16BitFormatter();


///////////////////////////////////////////////////////////////////////////////
// AUDIOFormatter declarations
///////////////////////////////////////////////////////////////////////////////

public:
    const snd_pcm_format_t format()
    {
        return SND_PCM_FORMAT_S16_LE;
    }

    void format_samples(uint8_t *raw_buffer_p, AUDIOChannel::Index index, AUDIOChannel::Sample *sample_buffer_p, size_t num_samples);

    const size_t sample_sizeof()
    {
        return sizeof(int16_t);
    }
};

///////////////////////////////////////////////////////////////////////////////
// class definition
///////////////////////////////////////////////////////////////////////////////

class AUDIOSigned32BitFormatter : public AUDIOFormatter
{

///////////////////////////////////////////////////////////////////////////////
// public function declarations
///////////////////////////////////////////////////////////////////////////////

public:
    AUDIOSigned32BitFormatter();
    ~AUDIOSigned32BitFormatter();


///////////////////////////////////////////////////////////////////////////////
// AUDIOFormatter declarations
///////////////////////////////////////////////////////////////////////////////

public:
    const snd_pcm_format_t format()
    {
        return SND_PCM_FORMAT_S32_LE;
    }

    void format_samples(uint8_t *raw_buffer_p, AUDIOChannel::Index index, AUDIOChannel::Sample *sample_buffer_p, size_t num_samples);

    const size_t sample_sizeof()
    {
        return sizeof(int32_t);
    }
};

class AUDIOFloatFormatter : public AUDIOFormatter
{

///////////////////////////////////////////////////////////////////////////////
// public function declarations
///////////////////////////////////////////////////////////////////////////////

public:
    AUDIOFloatFormatter();
    ~AUDIOFloatFormatter();

///////////////////////////////////////////////////////////////////////////////
// AUDIOFormatter declarations
///////////////////////////////////////////////////////////////////////////////


public:
    const snd_pcm_format_t format()
    {
        return SND_PCM_FORMAT_FLOAT_LE;
    }

    void format_samples(uint8_t *raw_buffer_p, AUDIOChannel::Index index, AUDIOChannel::Sample *sample_buffer_p, size_t num_samples);

    const size_t sample_sizeof()
    {
        return sizeof(float);
    }
};





#endif
